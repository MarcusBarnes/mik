<?php
// src/metadataparsers/csv/Csv.php

/**
 * Metadata parser class that writes metadata out to a CSV file.
 */

namespace mik\metadataparsers\csv;

// use mik\metadataparsers\MetadataParser;
use League\Csv\Writer;
use Monolog\Logger;

class DcToCsv extends Csv
{
    /**
     * Create a new metadata parser instance
     */
    public function __construct($settings)
    {
        // Call Metadata.php contructor
        parent::__construct($settings);

        // The CSV writer that writes out object metadata is instantiated in the writer.
        $headings = $this->settings['METADATA_PARSER']['dc_elements'];
        array_unshift($headings, $this->settings['METADATA_PARSER']['record_key']);
        $output_file_path = $this->settings['WRITER']['output_file'];
        $output_csv_writer = Writer::createFromPath($output_file_path, 'a');
        $output_csv_writer->insertOne($headings);
    }

  /**
     * {@inheritdoc}
     *
     *  Returns the output of the template.
     */
    public function metadata($record_key)
    {
        $objectInfo = $this->fetcher->getItemInfo($record_key);
        $metadata = $this->populateRow($record_key, $objectInfo);
        return $metadata;
    }

    /**
     * Converts the item's metadata into an array.
     *
     * @param string $record_key
     *   The current item's record_key.
     * @param object $objectInfo
     *   The current item's metadata as generated by the fetcher.
     *
     * @return array
     *   The row, as an array.
     */
    public function populateRow($record_key, $objectInfo)
    {
       $record = $this->getDcValues($objectInfo);
       $row = array();

       // Field will be named in metadata parser's 'record_key' config setting.
       $row[] = $record_key;

       foreach ($this->settings['METADATA_PARSER']['dc_elements'] as $element) {
           // @todo: parse out multiple values and add them to the CSV separated
           // by a character; what does Migrate Plus want?
           foreach ($record as $record_element => $record_values) {
               if ($element == $record_element) {
                   if (count($record_values) > 0) {
                       $row[] = $record_values[0];
                   }
                   else {
                       $row[] = '';
                   }
               }
           }
       }

       if (isset($this->metadatamanipulators)) {
           $record = $this->applyMetadatamanipulators($record_key, $xml_from_template);
       }

        return $row;
    }

    /**
     * Applies metadatamanipulators listed in the config to provided serialized XML document.
     *
     * @param string $record_key
     *   The current item's record_key.
     * @param array $row
     *     An associative array containing the object's metadata.
     *
     * @return array
     *     The modified associative array containing the object's metadata.
     */
    public function applyMetadatamanipulators($record_key, $row)
    {
        foreach ($this->metadatamanipulators as $metadatamanipulator) {
            $metadatamanipulatorClassAndParams = explode('|', $metadatamanipulator);
            $metadatamanipulatorClassName = array_shift($metadatamanipulatorClassAndParams);
            $manipulatorParams = $metadatamanipulatorClassAndParams;
            $metdataManipulatorClass = 'mik\\metadatamanipulators\\' . $metadatamanipulatorClassName;
            $metadatamanipulator = new $metdataManipulatorClass($this->settings, $manipulatorParams, $record_key);
            $modified_xml = $metadatamanipulator->manipulate($xml);
        }

        // return $modified_xml;
        return $modified_row;
    }

    /**
     * Parses a DC XML document into an array.
     *
     * @param string $xml
     *   The DC XML document.
     *
     * @return array
     *   An associative array containing element name => element values.
     */
    public function getDcValues($xml) {
      $dc_values = array();
      $dom = new \DomDocument();
      $dom->loadXML($xml);
      $elements = $dom->getElementsByTagNameNS('http://purl.org/dc/elements/1.1/', '*');
      foreach ($elements as $e) {
        if (!array_key_exists($e->localName, $dc_values)) {
          $dc_values[$e->localName] = array();
          $dc_values[$e->localName][] = $e->nodeValue;
        }
        else {
          $dc_values[$e->localName][] = $e->nodeValue;
        }
      }
      return $dc_values;
    }
}
