<?php

/**
 * Post-write hook script for MIK that generates a compound object
 * structure file from a directory structure. Used by the CSV compound
 * toolchain.
 */

$input_dir = trim($argv[1]);
$output_path = '/tmp/test.structure';

/*
require 'vendor/autoload.php';

use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use GuzzleHttp\Client;

$record_key = trim($argv[1]);
$children_record_keys = explode(',', $argv[2]);
$config_path = trim($argv[3]);
$config = parse_ini_file($config_path, true);

$log = new Logger('postwritehooks/validate_mods.php');
$log->pushHandler(new StreamHandler($config['LOGGING']['path_to_log'], Logger::INFO));
*/


/**
 * Main script logic.
 */

$dom = new DOMDocument();
$dom->loadXML('<islandora_compound_structure />');
$root = $dom->firstChild;
$comment_text = "Islandora compound structure file generated by MIK.\n";
$comment_text .= "      On batch ingest, 'parent' elements will become compound objects, and 'child' elements will\n";
$comment_text .= "      become their children. Files in directories named in child elements' 'content' attribute\n";
$comment_text .= "      will be added as their datastreams. If 'parent' elements do not contain a MODS.xml file,\n";
$comment_text .= "      the value of the 'parent' 'title' attribute will be used as the parent's title/label.";
$comment = $dom->createComment($comment_text);
$root->appendChild($comment);

/*
 * This script produces an XML file corresponding to a filesystem directory tree as follows:
 * - all directories that contain no subdirectories, only content files, are represented by <child> elements
 *   (equivalent to <page> elements in Cdm). <child> elements have a single <content> attribute that
 *   contains the name of the directory where their content is stored, similar to Cdm's <pageptr> element.
 * - all directories that contain other directories (<child> and <parent>) are represented
 *   by <parent> (equivalent to <node> in Cdm). <parent> elements can have a <title> attribute
 *   that contains data similar to <nodetitle> in Cdm.
 *
 * Problem: parents that are children of other parents are not getting their title attribute added.
 */

foreach (glob($input_dir . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR) as $path) {
    if (is_dir($path)) {
        $type = get_directory_type($path);
        $dir_name = get_dir_name($path);
        $top_level_object_element = $dom->createElement($type);
        $top_level_object_element = append_child_dirs($dom, $top_level_object_element, $path);
        if ($type == 'parent') {
            $top_level_object_element = add_parent_title($dom, $top_level_object_element, $dir_name);
        }
        if ($type == 'child') {      
            $top_level_object_element = add_child_content_dir($dom, $top_level_object_element, $dir_name);
        }
        $root->appendChild($top_level_object_element);
    }
}

$dom->formatOutput = true;
$dom->save($output_path);


/**
 * Recursive function to add child directories to the XML.
 */
function append_child_dirs($dom, $element, $path) {
    foreach (glob($path . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR) as $dir) {
        if (is_dir($dir)) {
            $type = get_directory_type($dir);
            $dir_name = get_dir_name($dir);
            $child = $dom->createElement($type);
            $child = append_child_dirs($dom, $child, $path . DIRECTORY_SEPARATOR . $dir_name);
            if ($type == 'parent') {
                $element = add_parent_title($dom, $element, $dir_name);
            }
            if ($type == 'child') {      
                $child = add_child_content_dir($dom, $child, $dir_name);
            }
            $element->appendChild($child);
        }
    }
    return $element;
}

function get_directory_type($dir) {
    $type = 'child';
    foreach (glob($dir . DIRECTORY_SEPARATOR . '*') as $member) {
        if (is_dir($member)) {
            $type = 'parent';
        }
    }
    return $type;
}

function add_parent_title($dom, $element, $dir_name) {
    $title_attribute = $dom->createAttribute('title');
    $title_attribute->value = $dir_name;
    $element->appendChild($title_attribute);
    return $element;
}

function add_child_content_dir($dom, $element, $dir_name) {
    $content_attribute = $dom->createAttribute('content');
    $content_attribute->value = $dir_name;
    $element->appendChild($content_attribute);  
    return $element;
}

/**
 * Removes path segments leading up to the last segment.
 */
function get_dir_name($path) {
    $dir_path = preg_replace('/(\.*)/', '', $path);
    $dir_path = rtrim($dir_path, DIRECTORY_SEPARATOR);
    $base_dir_pattern = '#^.*' . DIRECTORY_SEPARATOR . '#';
    $dir_path = preg_replace($base_dir_pattern, '', $dir_path);
    $dir_path = ltrim($dir_path, DIRECTORY_SEPARATOR);
    return $dir_path;
}